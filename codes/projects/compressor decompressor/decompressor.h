#pragma once

#include <fstream>
#include <iostream>
#include <string>

// Функция для декомпрессии RLE (Run-Length Encoding)
// Принимает имя входного и выходного файла
inline bool DecodeRLE(const std::string& src_name, const std::string& dst_name) {
    using namespace std;

    // Открываем входной файл для чтения в бинарном режиме
    ifstream in(src_name, ios::binary);
    if (!in) {
        return false; // Если файл не удалось открыть, возвращаем false
    }
    
    // Открываем выходной файл для записи в бинарном режиме
    ofstream out(dst_name, ios::binary);
     if (!out) {
        return false; // Если файл не удалось открыть, возвращаем false
    }
    // Бесконечный цикл для чтения блоков из входного файла
    do {
        char header_c; // Переменная для хранения заголовка блока
        if (!in.get(header_c)) {
            return true; // Если не удалось прочитать заголовок, значит, файл закончился
        }

        // Преобразуем символ заголовка в беззнаковый байт
        unsigned char header = static_cast<unsigned char>(header_c);

        // Вычисляем размер данных в блоке (размер + 1),>> сдвигает биты переменной header вправо на 1 позицию.
        size_t size = static_cast<size_t>(header >> 1) + 1;
        /*Сначала выполняется сдвиг header >> 1, который получает значение, равное половине значения header, округленное вниз (например, если header равно 5, то header >> 1 будет равно 2).
        Затем к этому значению добавляется 1. Это нужно для получения фактического размера блока, так как RLE кодирует размер блока с использованием нуля, чтобы указать, 
        что размер блока составляет от 1 до 128 (вместо 0 до 127). Добавление 1 возвращает это значение в диапазон от 1 до 128.*/

        // Максимальный размер блока
        static const int max_block_size = 128;
        char block[max_block_size]; // Массив для хранения данных блока

        // Проверяем тип блока: обычный (header & 1 == 0) или блок повторов (header & 1 == 1)
        if ((header & 1) == 0) {
            // Если блок обычный, читаем данные в массив
            if (!in.read(block, size)) {
                return false; // Если чтение не удалось, возвращаем false
            }
            out.write(block, size); // Записываем данные в выходной файл
        } else {
            // Если блок повторов, читаем символ
            char c;
            if (!in.get(c)) {
                return false; // Если чтение символа не удалось, возвращаем false
            }

            // Создаём строку, содержащую повторяющийся символ
            string s(size, c);
            out.write(s.data(), size); // Записываем строку в выходной файл
        }
    } while (in); // Продолжаем, пока есть данные во входном файле

    return true; // Возвращаем true, если декомпрессия прошла успешно
}
